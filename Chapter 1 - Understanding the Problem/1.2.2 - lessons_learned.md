# Title: Signing-Level Lessons from Web3 Multisig Failures

---

### ðŸ” UX Spoofing is the Dominant Attack Vector

> Most successful attacks didnâ€™t compromise keys â€” they **deceived signers at the UI level**.

- ðŸ”¥ Seen in: Bybit, Safe, Euler
- ðŸ“Ž Prevention: Hash-locked frontends, canonical txintent JSON, client hash validation, OOB review flows

---

### ðŸ§  All-Signer Deception is Real

> Multisig fails if **all participants trust the same poisoned input** â€” UX, relay, or shared device model.

- ðŸ”¥ Seen in: Bybit, Safe, Phemex
- ðŸ“Ž Solution: Signer diversity (device, region, role), multi-client approval (CLI + frontend), cold-mode display

---

### â›“ï¸ Low Quorum = High Risk

> Any system with 2-of-3, 2-of-5 becomes highly vulnerable to partial compromise or drift.

- ðŸ”¥ Seen in: Harmony
- ðŸ“Ž Mitigate with: Time locks, policy enforcement, high-value vault segregation

---

### ðŸ›  Approval Must Not Imply Execution

> Auto-execution is dangerous â€” it short-circuits human verification and forensic opportunity.

- ðŸ”¥ Seen in: BNB Chain
- ðŸ“Ž Solution: Explicit execution role, time delays, timelocks, executor role policy

---

### ðŸ›° APIs and Relay Layers Are Critical Surfaces

> JSON APIs and RPCs can be intercepted or spoofed to deliver manipulated txs, buffers, or metadata.

- ðŸ”¥ Seen in: Bybit (suspected), others
- ðŸ“Ž Use authenticated API relay, canonical buffer hashes, signed metadata, local simulation

---

### ðŸ§© Plugins and SDKs Must Be Policy-Gated

> Modular smart accounts can expand the attack surface via plugin injection unless strictly verified.

- ðŸ“Ž Solution: Policy contract required to install plugin; execution filters; hash-verified plugin registry

---

### ðŸŒ Frontend Must Be Verifiable

> Web3 UIs served from cloud (Netlify, Vercel) can be compromised without detection.

- ðŸ“Ž Solution: Onchain UX delivery (ICP), IPFS + local hash-checking, chain-verifiable deployment registry
